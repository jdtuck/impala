import numpy as np
import impala_noProbit_emu as impala
import models_withLik as models
import matplotlib.pyplot as plt
from importlib import reload
import pyBASS as pb

#%%


def f1(x):
    out = x[0]*tt*0 + x[0]
    return out
#


tt = np.linspace(0, 1, 50)
n = 300
p = 2
x = np.random.rand(n, p)
xx = np.random.rand(1000, p)
e = np.random.normal(size=n * len(tt))
y = np.apply_along_axis(f1, 1, x) + e.reshape(n,len(tt))*.001

modf = pb.bassPCA(x, y, ncores=1, npc=1, maxInt=1)

#%%
xx_true = np.random.rand(1, p)
#yobs1 = np.apply_along_axis(f1, 1, xx_true).reshape(len(tt)) + np.concatenate((np.random.normal(size=20)*.001, np.random.normal(size=30)*.03))
yobs2 = np.apply_along_axis(f1, 1, xx_true).reshape(len(tt)) + np.random.normal(size=50)*.04

#%%
input_names = [str(v) for v in list(range(p))]
bounds = dict(zip(input_names,np.concatenate((np.zeros((p,1)),np.ones((p,1))),1)))



def cf(x, bounds):
    k = list(bounds.keys())[0]
    good = x[k] < bounds[k][1]
    for k in list(bounds.keys()):
        good = good * (x[k] < bounds[k][1]) * (x[k] > bounds[k][0])
    return good

#%%

impala = reload(impala)
models = reload(models)

setup = impala.CalibSetup(bounds, cf)
model1 = models.ModelF(f1, input_names)
#model2 = models.ModelBassPca(modf, input_names)
#setup.addVecExperiments(yobs1, model1, sd_est=np.array([0,0]), s2_df=np.array([0,0]), s2_ind=np.array([0]*20 + [1]*30))
setup.addVecExperiments(yobs2, model1, sd_est=np.array([0.]), s2_df=np.array([0.]), s2_ind=np.array([0]*len(tt)))
setup.setTemperatureLadder(1.15**np.arange(3))
setup.setMCMC(15000,1000,1,100)
out = impala.calibPool(setup)
uu = np.arange(10000, 15000, 2)


plt.plot(np.sqrt(out.s2[0][5000:,0,0]))
plt.axhline(.04)
plt.show()

#%%
pred1 = setup.models[0].eval(impala.tran_unif(out.theta[:,0,:], setup.bounds_mat, setup.bounds.keys()))
plt.plot(pred1[uu,:].T,color='grey')
plt.plot(setup.ys[0])
plt.show()

#%%
import seaborn as sns
import pandas as pd
dat = pd.DataFrame(out.theta[uu,0,:])
dat = dat.append(pd.DataFrame(xx_true))
dat['col'] = ['blue']*len(uu) + ['red']
g = sns.pairplot(dat, plot_kws={"s": [3]*len(uu) + [50]}, corner=True, hue='col', diag_kind='hist')
g.set(xlim=(0,1), ylim = (0,1))
g
plt.show()
#%%
out.count
#%%
out.count_decor
#%%
out.cov_theta_cand.tau
out.cov_ls2_cand[0].tau
#%%
np.sqrt(out.s2)

#%%

import matplotlib.pyplot as plt
plt.plot(out.theta[:,0,0])
plt.show()

plt.plot(np.sqrt(out.s2[0][5000:,0,0]))
plt.axhline(.01)
plt.show()